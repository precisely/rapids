# Handling interruptions

During execution of a flow, it may be necessary to halt execution or redirect the flow. For example, a healthcare worker might determine that a patient should be taken off of an automated drug dosing management program. Alternatively some parameters might need to be changed, and a process restarted - for example, a dosage might need to be manually increased.

In Rapids, you can handle situations like these using `attempt` expressions. They are analogous to `try` expressions, in that normal control flow is redirected.  Unlike `try` expressions, which handle exceptions generated at runtime, `attempt` handles _interruptions_, which are generated external to a flow (for example, by a system administrator managing automated patient flows). Furthermore, although exceptions are generated during runtime, interruptions occur while a flow is suspended (i.e., saved to persistent storage in `:running` state). 

## attempt 
The `attempt` macro signature is as follows:

```clojure
(attempt exprs* handle-clauses* finally-clause?)
```

For example,
```clojure
(deflow my-interruptible-flow []
  (attempt
    ;; body of code, during which interruptions may happen
    (foo)   
    (restartable (bar)   ; an expression which may be restarted
      (:redo [o] (* o o)) ; restart can take any number of arguments and returns a value based on the arguments
    
    ;; handle or finally expressions end the attempt body
    (handle :xyzzy [data]
      (println data) ; prints interruption's data to stdout
      ...)                ; handle :xyzzy block's value is returned when an :xyzzy interrupt is encountered
    (handle :recalc [data]
      (restart :redo data))  ; the :recalc interrupttion passes the data to the :redo restart 
    (finally (do-stuff1) (do-stuff2)) ; this code is guaranteed to execute after either the attempt,
                                      ; but the return value is ignored
```

The `interrupt!` top-level API function can be used to generate an interruption when the run is suspended. This method visits attempt blocks checking for a matching interruption handler (the second argument should match the name field of the interruption). Note that while `attempt` expressions are used inside `deflow` bodies, `interrupt!` is a top-level function used for controlling runs, usually used outside of `deflow` (for example to implement a server API). It is a sibling of top-level functions, `start!` and `continue!`.

```clojure
(interrupt! run-id :xyzzy {:a 1 :b 2}) ; invoke interrupt :xyzzy, providing data {:a 1, :b 2}
```

### handle

Handlers are conceptually similar to `catch` clauses in expressions like `(handle :iname [data] ...body)`. The first argument, `iname`, is a keyword. When the handlers `iname` matches the name field of an interruption, the data provided to `interrupt!` is bound to `data` and the body is executed. The value generated by the last expression in body is returned by the attempt block, unless a handler is triggered or a restarted is invoked. 

Handlers also provide optional metadata. This is useful for applications which need to present richer context to users who may wish to trigger an interruption. A docstring and/or metadata map may precede the arglist vector.   

```clojure
(handle :name-of-interruption "this is the docstring" {:this-is-the "metadata"} [data] ...)
```

The docstring is incorporated as the `:doc` key of the interrupt handler's metadata. For example, to get the docstring of the first interrupt handler:

```clojure
(-> (list-interrupt-handlers) first :metadata :doc)
```

### finally

Finally blocks behave analogously to `finally` in `try` expressions. They take a list of expressions as an argument. The attempt macro guarantees that this code is executed immediately after the attempt body or a handler body is executed. In other words, `finally` blocks are guaranteed to execute whether or not an interruption is received. 

### restartable and restart

The `restartable` macro marks a point in code which may be revisted, and defines a restart containing one or more keyword-named flows. Once created, a restart persists until the outermost `attempt` block completes. Note this means that restarts can continue to exist even after the `attempt` block they were defined in has completed.  

```clojure
(restartable (do-step-1)
   (:step1/redo [a1 a2 a3] (redo-step1 a1 a2 a3))
   (:step1/recalculate [] (...)))
```

Inside attempt bodies, expressions can be wrapped with `restartable`, as `(bar)` is above. Restartable expressions take an expression as a first argument and one or more restart definitions as remaining arguments. Restarts are flow definitions with a keyword name. 

Restarts are invoked using the `restart` function.  This example shows how to transfer control to a previously established `:step1/redo` restart, providing some arguments

```clojure
(restart :step1/redo "with" "some" "arguments")
```
# Developer Notes

A grab bag of tips and tricks for the Rapids library developer.

## How to
### Create System Flows

**Problem**: The `deflow` macro cannot be used within the Rapids library due to a cryptic bug (explained below). 

**Solution**: hand-roll the flow, as shown in the definition of `raise`:

```Clojure
; from rapids.runtime.raise
(def raise (flow/->Flow `raise
             (fn [i] (flow/call-partition raise-address {:interrupt i}))
             {[0] #'raise-partition}))
```

The anonymous fn is the entry function, and it has a partition table with a single partition function, `raise-partition`.  

## Needs fixing

### Too many partition functions

Deeply nested suspending functions result in a large number of partition functions. This is due to the recursive nature of the partitioner. For example,

```Clojure
(foo (bar (baz (*))))
```

Is broken into four partitions. This is because the partitioner examines each function's arguments recursively, and creates a partition whenever arguments are suspending. So this is broken up into:

```Clojure
(*) ; partition 1 => result will be bound to <<1>> 

(baz <<1>>) ; partition 2 => <<2>>

(bar <<2>>) ; partition 3

(foo <<3>>) ; partition 4
```

However, this is unnecessary and inefficient, both in terms of consuming more stack frames, requiring more operations and producing more autogenerated variables. It should instead produce code like the following:

```Clojure
(*) ; partition 1

(foo (bar (baz <<0>>))) ; partition 2
```

One failed exploration of this is in the branch `aneil/node-partitioner`. Probably a better way to do this would be to use [clojure.tools.analyzer](https://github.com/clojure/tools.analyzer) or [muir](https://github.com/hugoduncan/muir).
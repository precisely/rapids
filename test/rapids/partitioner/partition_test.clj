(ns rapids.partitioner.partition_test
  (:require [clojure.core.match :refer [match]]
            [clojure.test :refer :all]
            [rapids.objects.address :as address]
            [rapids.partitioner.core :as pcore]
            [rapids.partitioner.partition :refer :all]
            [rapids.partitioner.partition-set :refer [addresses]]
            [rapids.support.util :refer :all]
            [rapids.objects.address :as a]
            [rapids.partitioner.partition-set :as pset])
  (:import (rapids.objects.flow Flow)))

(declare PARTITION-ADDRESS MAIN) ; get rid of symbol resolution warnings

(def fl1 (Flow. 'fl1 #() {}))
(def fl2 (Flow. 'fl2 #() {}))
(defn a [])
(defn b [])

(def partition-address (address/->address `PARTITION-ADDRESS))
(def address (address/->address `MAIN))

(deftest ^:unit PartitionLiterals
  (testing "literals"
    (testing "number"
      (is (= (partition-expr 123 partition-address address [])
            [123, nil, nil])))
    (testing "string"
      (is (= (partition-expr "foo" partition-address address [])
            ["foo", nil, nil])))))

(deftest ^:unit PartitionNonSuspendingFunctionalExpressions
  (testing "simple expression"
    (is (= (partition-expr '(+ 3 4) partition-address address [])
          ['(+ 3 4), nil, false])))
  (testing "nested expression"
    (is (= (partition-expr '(+ (* 3 4) 6) partition-address address [])
          ['(+ (* 3 4) 6), nil, false]))))

(deftest ^:unit PartitionSuspendingFunctionalExpressions
  (testing "suspending expressions"
    (testing "flow with non-suspending args"
      (is (= (partition-expr `(fl1 3 4) partition-address address [])
            [`(rapids/fcall fl1 3 4), nil, true])))
    (testing "flow with suspending args"
      (let [[start, pset, suspend?]
            (partition-expr `(fl1 (fl2 (a))) partition-address address '[z])
            next-address (address/child address `fl1 1)] ; fl1/0 is arg0, fl1/1 => "(fl1 ~arg0)"
        (is (true? suspend?))
        (testing "the start body should contain a resume-at expression pointing at the next-address, starting with the innermost term"
          (is (match [start]
                [([`rapids.partitioner.resume-at/resume-at [next-address ['z] _]
                   ([`rapids/fcall `fl2 ([`a] :seq)] :seq)] :seq)] true
                [_] false)))
        (testing "the partition set should contain a partition which evals the outer flow"
          (is (map? pset))
          (is (= (-> pset addresses count) 1))
          (let [pdef   (get pset next-address)
                params (:params pdef)]
            (is (not (nil? pdef)))
            (testing "the params should contain the input param (z) and an autogenerated parameter representing the result from the nested flow"
              (is (in? params 'z))
              (is (= (count params) 2)))
            (is (match [(:body pdef)]
                  [[([`rapids/fcall `fl1 _] :seq)]] true
                  [_] false))))))))

(deftest ^:unit PartitionBody
  (testing "body without forms"
    (is (match [(partition-body [] partition-address address [])]
          [[[], {} false]] true
          [_] false)))

  (testing "body without suspending forms"
    (let [[start, pset, suspend?] (partition-body `[(a) (b)] partition-address address [])]
      (is (match [start]
            [[([`a] :seq), ([`b] :seq)]] true
            [_] false))
      (is (= (count (dissoc pset :unforced)) 0)) ;; only the :unforced key
      (is (false? suspend?))))

  (testing "body with a single suspending form"
    (let [[start, pset, suspend?] (partition-body `[(fl1)] partition-address address [])]
      (is (match [start]
            [[([`rapids/fcall `fl1] :seq)]] true
            [_] false))
      (is (= (-> pset addresses count) 0))
      (is (true? suspend?))))

  (testing "body split by a suspending form"
    (let [[start, pset, suspend?] (partition-body `[(a) (fl1) (b)] partition-address address [])
          part2-address (address/child address 2)]

      (testing "initial form first two forms, resuming at the second partition address"
        (is (match [start]
              [[([`a] :seq)
                ([`rapids.partitioner.resume-at/resume-at [part2-address [] _]
                  ([`rapids/fcall `fl1] :seq)] :seq)]] true
              [_] false))
        (is (true? suspend?)))

      (testing "there should be one partition with the final expr"
        (is (= (-> pset addresses count) 1))
        (let [cdef (get pset part2-address)]
          (is (= (get cdef :params) '[]))
          (is (= (get cdef :body) `[(b)])))))))

(deftest ^:unit PartitionConditionalExpression)

(deftest ^:unit PartitionLetExpression)

(deftest ^:unit PartitionLoopExpression)

(deftest ^:unit PartitionVectorExpression
  (testing "simple vector with scalars"
    (let [[start, pset, suspend?] (partition-vector-expr `["str" :key 1] partition-address address [])]
      (is (false? suspend?))
      (is (empty? pset))
      (is (= start ["str" :key 1]))))

  (testing "vector with function calls"
    (let [[start, pset, suspend?] (partition-vector-expr `[(a) (b) 3] partition-address address [])]
      (is (= 0 (count pset)))
      (is (false? suspend?))
      (is (match [start]
            [[([a] :seq) ([b] :seq) 3]] true
            [_] false))))

  (testing "vector with suspending expressions"
    (let [[start, pset, suspend?] (partition-vector-expr `[(fl1) (fl2) 3] partition-address address [])]
      (is (= 2 (-> pset addresses count)))
      (is (true? suspend?))
      (is (match [start]
            [([`rapids.partitioner.resume-at/resume-at [_ [] _] ([`rapids/fcall `fl1] :seq)] :seq)] true
            [_] false)))))


(deftest ^:unit PartitionSetExpression
  (testing "simple set with scalars"
    (let [[start, pset, suspend?] (partition-set-expr `#{"str" :key 1} partition-address address [])]
      (is (false? suspend?))
      (is (empty? pset))
      (is (= start #{"str" :key 1}))))

  (testing "set with function calls"
    (let [[start, pset, suspend?] (partition-set-expr `#{(a) (b) 3} partition-address address [])]
      (is (= 0 (count pset)))
      (is (false? suspend?))
      (is (= start `#{(a) (b) 3}))))

  (testing "set with suspending expressions"
    (let [[start, pset, suspend?] (partition-set-expr `#{(fl1) (fl2) 3} partition-address address [])]
      (is (= 2 (-> pset addresses count)))
      (is (true? suspend?))
      (testing "one of the two suspending expressions is in start"
        (is (match [start]
              [([`rapids.partitioner.resume-at/resume-at [_ [] _] ([`rapids/fcall _] :seq)] :seq)] true
              [_] false))))))

(deftest ^:unit PartitionBindings
  (with-redefs [rapids.objects.flow/flow-symbol? #{'suspending-flow}]
    (let [p-addr    (a/->address `foo 0 'myfn)
          body-addr p-addr
          addr      body-addr
          params    '[p1]]
      (testing "non-suspending expression"
        (let [syms        '[s1 s2 s3]
              args        '[(foo 1) (bar 2) nil]
              accumulate? true
              [_start, _pset, _suspending-count, _final-partition-pset, _final-bindings-index, _final-params]
              (partition-bindings-new syms args accumulate? p-addr body-addr addr params)]

          (is (= _start nil))
          (is (= (pset/size _pset) 0))
          (is (= _suspending-count 0))
          (is (= (pset/size _final-partition-pset) 0))
          (is (= _final-bindings-index 0))
          (is (= _final-params '[p1]))))

      (testing "single suspending argument at start"
        (let [syms        '[s1 s2 s3]
              args        '[(suspending-flow) (foo) nil]
              accumulate? true
              [_start, _pset, _suspending-count, _final-partition-pset, _final-bindings-index, _final-params]
              (partition-bindings-new syms args accumulate? p-addr body-addr addr params)]

          (is (= _start '(rapids/fcall suspending-flow)))
          (is (= (pset/size _pset) 0))
          (is (= _suspending-count 1))
          (is (= (pset/size _final-partition-pset) 1))
          (is (= _final-bindings-index 1))
          (is (= _final-params '[p1 s1]))))

      (testing "single suspending argument in middle"
        (let [syms        '[s1 s2 s3]
              args        '[(foo) (suspending-flow) nil]
              accumulate? true
              [_start, _pset, _suspending-count, _final-partition-pset, _final-bindings-index, _final-params]
              (partition-bindings-new syms args accumulate? p-addr body-addr addr params)]

          (is (= _start '(rapids/fcall suspending-flow)))
          (is (= (pset/size _pset) 0))
          (is (= _suspending-count 1))
          (is (= (pset/size _final-partition-pset) 1))
          (is (= _final-bindings-index 2))
          (is (= _final-params '[p1 s1 s2]))

          (testing "single suspending argument in middle, no accumulation"
            (let [accumulate? false
                  [_start, _pset, _suspending-count, _final-partition-pset, _final-bindings-index, _final-params]
                  (partition-bindings-new syms args accumulate? p-addr body-addr addr params)]

              (is (= _final-params '[p1]))))))

      (testing "multiple suspending arguments"
        (let [syms        '[s1 s2 s3 s4 s5 s6 s7]
              args        '[(foo) (suspending-flow) (foo) (suspending-flow) (bar) (suspending-flow) (bar)]
              accumulate? true
              [_start, _pset, _suspending-count, _final-partition-pset, _final-bindings-index, _final-params]
              (partition-bindings-new syms args accumulate? p-addr body-addr addr params)]

          (is (= _start '(rapids/fcall suspending-flow)))
          (is (= (pset/size _pset) 2))
          (is (= _suspending-count 3))
          (is (= (pset/size _final-partition-pset) 1))
          (is (= _final-bindings-index 6))
          (is (= _final-params '[p1 s1 s2 s3 s4 s5 s6])))))))
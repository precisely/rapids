(ns rapids.partitioner.partition_test
  (:require [clojure.test :refer :all]
            [rapids.support.util :refer :all]
            [clojure.core.match :refer [match]]
            [rapids.partitioner.core :refer :all]
            [rapids.partitioner.partition :refer [partition-vector-expr]]
            [rapids.partitioner.partition-set :refer [addresses]]
            [rapids.objects.address :as address]
            [rapids.language.operators :as operators])
  (:import (rapids.objects.flow Flow)))

(declare PARTITION-ADDRESS MAIN) ; get rid of symbol resolution warnings

(def fl1 (Flow. 'fl1 #() {} {}))
(def fl2 (Flow. 'fl2 #() {} {}))
(defn a [])
(defn b [])

(def partition-address (address/->address `PARTITION-ADDRESS))
(def address (address/->address `MAIN))

(deftest ^:unit PartitionLiterals
  (testing "literals"
    (testing "number"
      (is (= (partition-expr 123 partition-address address [])
            [123, nil, nil])))
    (testing "string"
      (is (= (partition-expr "foo" partition-address address [])
            ["foo", nil, nil])))))

(deftest ^:unit PartitionNonSuspendingFunctionalExpressions
  (testing "simple expression"
    (is (= (partition-expr '(+ 3 4) partition-address address [])
          ['(+ 3 4), nil, false])))
  (testing "nested expression"
    (is (= (partition-expr '(+ (* 3 4) 6) partition-address address [])
          ['(+ (* 3 4) 6), nil, false]))))

(deftest ^:unit PartitionSuspendingFunctionalExpressions
  (testing "suspending expressions"
    (testing "flow with non-suspending args"
      (is (= (partition-expr `(fl1 3 4) partition-address address [])
            [`(rapids.language.operators/fcall fl1 3 4), nil, true])))
    (testing "flow with suspending args"
      (let [[start, pset, suspend?]
            (partition-expr `(fl1 (fl2 (a))) partition-address address '[z])
            next-address (address/child address `fl1 1)] ; fl1/0 is arg0, fl1/1 => "(fl1 ~arg0)"
        (is (true? suspend?))
        (testing "the start body should contain a resume-at expression pointing at the next-address, starting with the innermost term"
          (is (match [start]
                [([`rapids.partitioner.partition/resume-at [next-address ['z] _]
                   ([`operators/fcall `fl2 ([`a] :seq)] :seq)] :seq)] true
                [_] false)))
        (testing "the partition set should contain a partition which evals the outer flow"
          (is (map? pset))
          (is (= (-> pset addresses count) 1))
          (let [pdef   (get pset next-address)
                params (:params pdef)]
            (is (not (nil? pdef)))
            (testing "the params should contain the input param (z) and an autogenerated parameter representing the result from the nested flow"
              (is (in? params 'z))
              (is (= (count params) 2)))
            (is (match [(:body pdef)]
                  [[([`operators/fcall `fl1 _] :seq)]] true
                  [_] false))))))))

(deftest ^:unit PartitionBody
  (testing "body without forms"
    (is (match [(partition-body [] partition-address address [])]
          [[[], {} false]] true
          [_] false)))

  (testing "body without suspending forms"
    (let [[start, pset, suspend?] (partition-body `[(a) (b)] partition-address address [])]
      (is (match [start]
            [[([`a] :seq), ([`b] :seq)]] true
            [_] false))
      (is (= (count (dissoc pset :unforced)) 0)) ;; only the :unforced key
      (is (false? suspend?))))

  (testing "body with a single suspending form"
    (let [[start, pset, suspend?] (partition-body `[(fl1)] partition-address address [])]
      (is (match [start]
            [[([`operators/fcall `fl1] :seq)]] true
            [_] false))
      (is (= (-> pset addresses count) 0))
      (is (true? suspend?))))

  (testing "body split by a suspending form"
    (let [[start, pset, suspend?] (partition-body `[(a) (fl1) (b)] partition-address address [])
          part2-address (address/child address 2)]

      (testing "initial form first two forms, resuming at the second partition address"
        (is (match [start]
              [[([`a] :seq)
                ([`rapids.partitioner.partition/resume-at [part2-address [] _]
                  ([`operators/fcall `fl1] :seq)] :seq)]] true
              [_] false))
        (is (true? suspend?)))

      (testing "there should be one partition with the final expr"
        (is (= (-> pset addresses count) 1))
        (let [cdef (get pset part2-address)]
          (is (= (get cdef :params) '[]))
          (is (= (get cdef :body) `[(b)])))))))

(deftest ^:unit PartitionConditionalExpression)

(deftest ^:unit PartitionLetExpression)

(deftest ^:unit PartitionLoopExpression)

(deftest ^:unit PartitionVectorExpression
  (testing "simple vector with scalars"
    (let [[start, pset, suspend?] (partition-vector-expr `["str" :key 1] partition-address address [])]
      (is (false? suspend?))
      (is (empty? pset))
      (is (= start ["str" :key 1]))))

  (testing "vector with function calls"
    (let [[start, pset, suspend?] (partition-vector-expr `[(a) (b) 3] partition-address address [])]
      (is (= 0 (count pset)))
      (is (false? suspend?))
      (is (match [start]
            [[([a] :seq) ([b] :seq) 3]] true
            [_] false))))

  (testing "vector with suspending expressions"
    (let [[start, pset, suspend?] (partition-vector-expr `[(fl1) (fl2) 3] partition-address address [])]
      (is (= 2 (-> pset addresses count)))
      (is (true? suspend?))
      (is (match [start]
            [([`rapids.partitioner.partition/resume-at [_ [] _] ([`operators/fcall `fl1] :seq)] :seq)] true
            [_] false)))))


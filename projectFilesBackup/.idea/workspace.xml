<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="BranchesTreeState">
    <expand>
      <path>
        <item name="ROOT" type="e8cecc67:BranchNodeDescriptor" />
        <item name="LOCAL_ROOT" type="e8cecc67:BranchNodeDescriptor" />
      </path>
      <path>
        <item name="ROOT" type="e8cecc67:BranchNodeDescriptor" />
        <item name="REMOTE_ROOT" type="e8cecc67:BranchNodeDescriptor" />
      </path>
      <path>
        <item name="ROOT" type="e8cecc67:BranchNodeDescriptor" />
        <item name="REMOTE_ROOT" type="e8cecc67:BranchNodeDescriptor" />
        <item name="GROUP_NODE:origin" type="e8cecc67:BranchNodeDescriptor" />
      </path>
    </expand>
    <select />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="d0d179df-efbc-47b8-ae64-dcc8967a347e" name="Default Changelist" comment="asd" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
        <option value="Clojure Test Namespace" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="ProjectId" id="1h1RlzenHZP3eRKRURNSYi2acn3" />
  <component name="ProjectLevelVcsManager">
    <ConfirmationsSetting value="2" id="Add" />
  </component>
  <component name="ProjectViewState">
    <option name="autoscrollFromSource" value="true" />
    <option name="autoscrollToSource" value="true" />
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">
    <property name="ASKED_ADD_EXTERNAL_FILES" value="true" />
    <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="com.intellij.ide.scratch.LRUPopupBuilder$1/New Scratch File" value="Clojure&#10;TEXT" />
    <property name="cursive.last.file.extension./Users/aneil/code/experiments/longterm/src" value="clj" />
    <property name="cursive.last.file.extension./Users/aneil/code/precisely/longterm/test" value="clj" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="project.structure.last.edited" value="Libraries" />
    <property name="project.structure.proportion" value="0.15" />
    <property name="project.structure.side.proportion" value="0.0" />
    <property name="settings.editor.selected.configurable" value="preferences.keymap" />
  </component>
  <component name="RecentsManager">
    <key name="MoveFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/src/longterm" />
      <recent name="$PROJECT_DIR$/test" />
      <recent name="$PROJECT_DIR$/src/longterm/util" />
    </key>
  </component>
  <component name="ReplState" timestamp="1607073848019">{:repl-history {:ide [], :local [{:command &quot;#(* % 4)&quot;, :offset 8, :ns &quot;longterm&quot;} {:command &quot;`#(* % 4)&quot;, :offset 9, :ns &quot;longterm&quot;} {:command &quot;(go #(go (* % %)))&quot;, :offset 18, :ns &quot;longterm&quot;} {:command &quot;(defprotocol foo (bar [a b {:keys [c d]}]))&quot;, :offset 43, :ns &quot;longterm&quot;} {:command &quot;(defn foo [&amp; {:keys [a b]}] (list a b))&quot;, :offset 39, :ns &quot;longterm&quot;} {:command &quot;(defn foo [ {:keys [a b]}] (list a b))&quot;, :offset 38, :ns &quot;longterm&quot;} {:command &quot;(foo {'a 1 'b 2})&quot;, :offset 17, :ns &quot;longterm&quot;} {:command &quot;(foo {:a 1 :b 2})&quot;, :offset 17, :ns &quot;longterm&quot;} {:command &quot;{#(* % %) 1}&quot;, :offset 12, :ns &quot;longterm&quot;} {:command &quot;(macroexpand '(deflow greeting [day-of-week]\n                (respond! \&quot;Hi. What is your name?\&quot;)\n                (let [name (listen!)] ;; listen! is a suspending operation \n                  (respond! \&quot;Nice to meet you,\&quot; name)\n                  (respond! \&quot;It's a very nice \&quot; day-of-week)\n                  name)) ;; return the name of the user\n  \n  )&quot;, :offset 350, :ns &quot;longterm&quot;} {:command &quot;(defn a [a b] (list a b))&quot;, :offset 25, :ns &quot;longterm&quot;} {:command &quot;(macroexpand '\n    (deflow foo []\n      (a 1 2)\n      (a (listen!) 3)\n      (a 4 5)))&quot;, :offset 85, :ns &quot;longterm&quot;} {:command &quot;(try (throw (Exception. \&quot;foo\&quot;)) (catch Exception e (throw (AssertionError. \&quot;bar\&quot;))) (catch AssertionError ae (println \&quot;hi\&quot;) :bar))&quot;, :offset 130, :ns &quot;longterm&quot;} {:command &quot;(try (throw (Exception. \&quot;foo\&quot;)) (catch Exception e :foo) (catch AssertionError ae (println \&quot;hi\&quot;) :bar))&quot;, :offset 103, :ns &quot;longterm&quot;} {:command &quot;(try (throw (AssertionError \&quot;foo\&quot;)) (catch Exception e :foo) (catch AssertionError ae (println \&quot;hi\&quot;) :bar))&quot;, :offset 107, :ns &quot;longterm&quot;} {:command &quot;(try (throw (AssertionError. \&quot;foo\&quot;)) (catch Exception e :foo) (catch AssertionError ae (println \&quot;hi\&quot;) :bar))&quot;, :offset 108, :ns &quot;longterm&quot;} {:command &quot;(try (throw (Exception. \&quot;hi\&quot;)) (catch Exception e :foo) (finally :bar))&quot;, :offset 71, :ns &quot;longterm&quot;} {:command &quot;(try (throw (Exception. \&quot;hi\&quot;)) (catch Exception e :foo) (finally (println :bar) :bar))&quot;, :offset 86, :ns &quot;longterm&quot;} {:command &quot;(try (throw (Exception. \&quot;hi\&quot;)) (finally (println :bar) :bar))&quot;, :offset 61, :ns &quot;longterm&quot;} {:command &quot;(java.util.UUID/randomUUID)&quot;, :offset 27, :ns &quot;longterm&quot;} {:command &quot;(macroexpand '(deflow loop-with-fcall [given-flows]\n                (loop [results []\n                       [flow &amp; flows] given-flows]\n                  (println flow)\n\n                  (let [new-results (conj results (fcall flow))]\n                    (if (rest flows)\n                      (recur new-results flows)))))\n  )&quot;, :offset 328, :ns &quot;longterm&quot;} {:command &quot;(macroexpand '(deflow apply-flows [forms]\n                (doseq [[op a1 &amp; rest-args] forms]\n                  (fapply op a1 rest-args)))\n  )&quot;, :offset 141, :ns &quot;longterm&quot;} {:command &quot;(symbol \&quot;asdf:1/a/a/b/d\&quot;)&quot;, :offset 25, :ns &quot;longterm&quot;} {:command &quot;(fn a:1_2_3 [a ] (* a a))&quot;, :offset 25, :ns &quot;longterm&quot;} {:command &quot;(.getName \&quot;\&quot;)&quot;, :offset 13, :ns &quot;longterm&quot;} {:command &quot;(let [x 1] (fn [y] (* y x)))&quot;, :offset 28, :ns &quot;longterm&quot;} {:command &quot;(def closure (let [x 1] (fn [y] (* y x))))&quot;, :offset 42, :ns &quot;longterm&quot;} {:command &quot;(require '[clojure.reflect :as r])&quot;, :offset 34, :ns &quot;longterm&quot;} {:command &quot;(r/reflect closure)&quot;, :offset 19, :ns &quot;longterm&quot;} {:command &quot;(:x closure)&quot;, :offset 12, :ns &quot;longterm&quot;} {:command &quot;(.getFields closure)&quot;, :offset 20, :ns &quot;longterm&quot;} {:command &quot;(.getFields (.getClass closure))&quot;, :offset 32, :ns &quot;longterm&quot;} {:command &quot;(.getField (.getClass closure) 'x)&quot;, :offset 34, :ns &quot;longterm&quot;} {:command &quot;(.getField (.getClass closure) \&quot;x\&quot;)&quot;, :offset 35, :ns &quot;longterm&quot;} {:command &quot;(-&gt; closure class .getDeclaredFields)&quot;, :offset 37, :ns &quot;longterm&quot;} {:command &quot;(-&gt; closure class .getDeclaredFields .get)&quot;, :offset 42, :ns &quot;longterm&quot;} {:command &quot;(map #(.get % closure) (-&gt; closure class .getDeclaredFields))&quot;, :offset 61, :ns &quot;longterm&quot;} {:command &quot;(map println (-&gt; closure class .getDeclaredFields))&quot;, :offset 51, :ns &quot;longterm&quot;} {:command &quot;(first (-&gt; closure class .getDeclaredFields))&quot;, :offset 45, :ns &quot;longterm&quot;} {:command &quot;(.get (first (-&gt; closure class .getDeclaredFields)) closure)&quot;, :offset 60, :ns &quot;longterm&quot;} {:command &quot;(require '[clojure.tools.analyzer.ast :as ast])&quot;, :offset 47, :ns &quot;longterm&quot;} {:command &quot;(ast )&quot;, :offset 5} {:command &quot;(require '[clojure.tools.analyzer :refer [analyze]])&quot;, :offset 52, :ns &quot;longterm&quot;} {:command &quot;(analyze 'a {})&quot;, :offset 15, :ns &quot;longterm&quot;} {:command &quot;(require '[clojure.tools.analyzer :as ana])\n(require '[clojure.tools.analyzer.env :as env])\n&quot;, :offset 92, :ns &quot;longterm&quot;} {:command &quot;(require '[clojure.tools.analyzer :as ana])\n(require '[clojure.tools.analyzer.env :as env])\n(defn analyze [form env]\n  (binding [ana/macroexpand-1 macroexpand-1\n            ana/create-var    create-var\n            ana/parse         parse\n            ana/var?          var?]\n    (env/ensure (global-env)\n      (run-passes (-analyze form env)))))&quot;, :offset 344, :ns &quot;longterm&quot;} {:command &quot;(require '[clojure.tools.analyzer.jvm :as ana])&quot;, :offset 47, :ns &quot;longterm&quot;} {:command &quot;(ana/analyzer)&quot;, :offset 14, :ns &quot;longterm&quot;} {:command &quot;(ana/analyze)&quot;, :offset 13, :ns &quot;longterm&quot;} {:command &quot;(require '[clojure.tools.analyzer.jvm :refer [analyze]])&quot;, :offset 56, :ns &quot;longterm&quot;} {:command &quot;(analyze '(fn [x] (* x y)))&quot;, :offset 27, :ns &quot;longterm&quot;} {:command &quot;(analyze '(let [y 3] (fn [x] (* x y))))&quot;, :offset 39, :ns &quot;longterm&quot;} {:command &quot;(:body (analyze '(let [y 3] (fn [x] (* x y)))))&quot;, :offset 47, :ns &quot;longterm&quot;} {:command &quot;(:body (analyze '(let [a 1 b 2 c 3] (fn [x] (* x a)))))&quot;, :offset 55, :ns &quot;longterm&quot;} {:command &quot;(dissoc :env (:body (analyze '(let [a 1 b 2 c 3] (fn [x] (* x a))))))&quot;, :offset 69, :ns &quot;longterm&quot;} {:command &quot;(dissoc (:body (analyze '(let [a 1 b 2 c 3] (fn [x] (* x a))))) :env)&quot;, :offset 69, :ns &quot;longterm&quot;} {:command &quot;(dissoc (:body (analyze '(let [xyzzy 1 b 2 c 3] (fn [x] (* x xyzzy))))) :env)&quot;, :offset 77, :ns &quot;longterm&quot;} {:command &quot;(require '[clojure.walk :refer [walk post-walk pre-walk]])&quot;, :offset 58, :ns &quot;longterm&quot;} {:command &quot;(require '[clojure.walk :refer [walk postwalk prewalk]])&quot;, :offset 56, :ns &quot;longterm&quot;} {:command &quot;(postwalk identity `(do (fn [x] (* x x))))&quot;, :offset 42, :ns &quot;longterm&quot;} {:command &quot;(postwalk #(if (and (symbol? %) (not (qualified-symbol? %))) % nil) `(do (fn [x] (* x x))))&quot;, :offset 91, :ns &quot;longterm&quot;} {:command &quot;(set (flatten (postwalk #(if (and (symbol? %) (not (qualified-symbol? %))) % nil) `(do (fn [x] (* x x))))))&quot;, :offset 107, :ns &quot;longterm&quot;} {:command &quot; (flatten (postwalk #(if (and (symbol? %) (not (qualified-symbol? %))) % nil) `(do (fn [x] (* x x)))))&quot;, :offset 102, :ns &quot;longterm&quot;} {:command &quot;  (postwalk #(if (and (symbol? %) (not (qualified-symbol? %))) % nil) `(do (fn [x] (* x x))))&quot;, :offset 93, :ns &quot;longterm&quot;} {:command &quot;(name 'a)&quot;, :offset 9, :ns &quot;longterm&quot;} {:command &quot;  (postwalk #(if (and (symbol? %) (not (qualified-symbol? %))) % nil) '(do (fn [x] (* x x))))&quot;, :offset 93, :ns &quot;longterm&quot;} {:command &quot;(tree-)&quot;, :offset 6} {:command &quot;  (postwalk #(do (println %) %) '(do (fn [x] (* x x))))&quot;, :offset 55, :ns &quot;longterm&quot;} {:command &quot;(let [symbols (postwalk #(do (println %) %) '(do (fn [x] (* x x))))&quot;, :offset 14} {:command &quot;(require '[longterm.util :refer :all])&quot;, :offset 38, :ns &quot;longterm&quot;} {:command &quot;(defn unqualified-symbol?[x] (and (symbol? x) (not (qualified-symbol? x))))&quot;, :offset 75, :ns &quot;longterm&quot;} {:command &quot;(unqualified-symbol? :x)&quot;, :offset 24, :ns &quot;longterm&quot;} {:command &quot;(unqualified-symbol? 'a)&quot;, :offset 24, :ns &quot;longterm&quot;} {:command &quot;(symbol :x)&quot;, :offset 11, :ns &quot;longterm&quot;} {:command &quot;(qualified-symbol? :x)&quot;, :offset 22, :ns &quot;longterm&quot;} {:command &quot;(defn get-variables [form]\n  (flatten (postwalk #(cond \n               (qualified-symbol? %) [%]\n               (seq? %) (get-variables %)\n               :else []) form)))&quot;, :offset 171, :ns &quot;longterm&quot;} {:command &quot;(defn get-variables [form]\n  (flatten (postwalk #(cond \n               (qualified-symbol? %) [%]\n               (nil? %) nil\n               (seq? %) (get-variables %)\n               :else nil) form)))&quot;, :offset 200, :ns &quot;longterm&quot;} {:command &quot;(defn get-variables [form]\n  (println form)\n  (flatten (postwalk #(cond \n               (qualified-symbol? %) [%]\n               (nil? %) nil\n               (seq? %) (get-variables %)\n               :else nil) form)))&quot;, :offset 217, :ns &quot;longterm&quot;} {:command &quot;(get-variables '(do (fn [x] (* x x ))))&quot;, :offset 39, :ns &quot;longterm&quot;} {:command &quot;(def form '(do (fn [x] (* x x)))) &quot;, :offset 34, :ns &quot;longterm&quot;} {:command &quot;(postwalk #(do (println %) %) form)&quot;, :offset 35, :ns &quot;longterm&quot;} {:command &quot;(flatten form)&quot;, :offset 14, :ns &quot;longterm&quot;} {:command &quot;(set (flatten form))&quot;, :offset 20, :ns &quot;longterm&quot;} {:command &quot;(set (flatten '({:a 1 a 2})))&quot;, :offset 29, :ns &quot;longterm&quot;} {:command &quot;(seq? {:a 1})&quot;, :offset 13, :ns &quot;longterm&quot;} {:command &quot;(map #(%) {:A 1})&quot;, :offset 17, :ns &quot;longterm&quot;} {:command &quot;(map #([%]) {:A 1})&quot;, :offset 19, :ns &quot;longterm&quot;} {:command &quot;(map #([%1 %2]) {:A 1})&quot;, :offset 23, :ns &quot;longterm&quot;} {:command &quot;(map #(list %) {:A 1})&quot;, :offset 22, :ns &quot;longterm&quot;} {:command &quot;(map #(identity %) {:A 1})&quot;, :offset 26, :ns &quot;longterm&quot;} {:command &quot;(def form (do (fn [x] (* x x {:a 3 :b {:c 3}}))))&quot;, :offset 49, :ns &quot;longterm&quot;} {:command &quot;(def form '(do (fn [x] (* x x {:a 3 :b {:c 3}}))))&quot;, :offset 50, :ns &quot;longterm&quot;} {:command &quot;(postwalk #(cond\n             (seq? %) (flatten %)\n             (map? %) (flatten (map identity %))\n             :else %) form)&quot;, :offset 127, :ns &quot;longterm&quot;} {:command &quot;(filter #'qualified-symbol (postwalk #(cond\n             (seq? %) (flatten %)\n             (map? %) (flatten (map identity %))\n             :else %) form))&quot;, :offset 155, :ns &quot;longterm&quot;} {:command &quot;(filter #'qualified-symbol? (postwalk #(cond\n             (seq? %) (flatten %)\n             (map? %) (flatten (map identity %))\n             :else %) form))&quot;, :offset 156, :ns &quot;longterm&quot;} {:command &quot;(filter qualified-symbol? (postwalk #(cond\n             (seq? %) (flatten %)\n             (map? %) (flatten (map identity %))\n             :else %) form))&quot;, :offset 154, :ns &quot;longterm&quot;} {:command &quot;(filter (constantly true) (postwalk #(cond\n             (seq? %) (flatten %)\n             (map? %) (flatten (map identity %))\n             :else %) form))&quot;, :offset 154, :ns &quot;longterm&quot;} {:command &quot;(filter unqualified-symbol? (postwalk #(cond\n             (seq? %) (flatten %)\n             (map? %) (flatten (map identity %))\n             :else %) form))&quot;, :offset 156, :ns &quot;longterm&quot;} {:command &quot;(macroexpand '(deflow flow-with-closure [x y z]\n                (let [closure  #(* % x)]\n                  (list (map closure y) z))))&quot;, :offset 134, :ns &quot;longterm&quot;} {:command &quot;(letfn [(list-sources [test-dir]\n          (map #(clojure.string/replace (second (re-matches (re-pattern (str test-dir \&quot;/(.*)\\\\.clj?$\&quot;)) (.getPath %))) \&quot;/\&quot; \&quot;.\&quot;)\n               (filter #(.isFile %) (file-seq (java.io.File. test-dir)))))]\n  (run! #(require (symbol %) :reload)\n        (list-sources \&quot;test\&quot;))\n  (clojure.test/run-all-tests #\&quot;longterm.*test.*\&quot;))&quot;, :offset 357, :ns &quot;longterm&quot;}], :remote []}}</component>
  <component name="RunAnythingCache">
    <option name="myCommands">
      <command value="mvn package" />
    </option>
  </component>
  <component name="RunManager">
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="SOCKET" />
      <setting name="configType" value="SPECIFY" />
      <setting name="replPortFileType" value="STANDARD" />
      <setting name="customPortFile" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="LeiningenRunConfiguration" factoryName="Leiningen">
      <module name="longterm" />
      <arguments argument="test-refresh" />
      <setting name="profiles" value="" />
      <setting name="trampoline" value="false" />
      <method v="2" />
    </configuration>
  </component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="d0d179df-efbc-47b8-ae64-dcc8967a347e" name="Default Changelist" comment="" />
      <created>1599176766955</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1599176766955</updated>
    </task>
    <task id="LOCAL-00001" summary="Improve start-run! signature &#10;&#10;* fix bug in resume-at&#10;* remove debug printing">
      <created>1601980553999</created>
      <option name="number" value="00001" />
      <option name="presentableId" value="LOCAL-00001" />
      <option name="project" value="LOCAL" />
      <updated>1601980553999</updated>
    </task>
    <task id="LOCAL-00002" summary="Get conditional flow tests working">
      <created>1602061991125</created>
      <option name="number" value="00002" />
      <option name="presentableId" value="LOCAL-00002" />
      <option name="project" value="LOCAL" />
      <updated>1602061991125</updated>
    </task>
    <task id="LOCAL-00003" summary="Get conditional flow tests working&#10;&#10;* convert all cljs files to clj to get rid of spurious symbol not found issues in IDE. We can add cljs support later if we need it.&#10;* fix warnings due to difficulty of importing InMemoryRunstore from a file with mismatched name">
      <created>1602083492910</created>
      <option name="number" value="00003" />
      <option name="presentableId" value="LOCAL-00003" />
      <option name="project" value="LOCAL" />
      <updated>1602083492910</updated>
    </task>
    <task id="LOCAL-00004" summary="Fix test cases">
      <created>1602084623494</created>
      <option name="number" value="00004" />
      <option name="presentableId" value="LOCAL-00004" />
      <option name="project" value="LOCAL" />
      <updated>1602084623494</updated>
    </task>
    <task id="LOCAL-00005" summary="Get if suspending-test case working&#10;&#10;* fix a small bug in the resume-at macro&#10;* rename runner to runloop.clj&#10;* convert remaining cljc =&gt; clj">
      <created>1602120477081</created>
      <option name="number" value="00005" />
      <option name="presentableId" value="LOCAL-00005" />
      <option name="project" value="LOCAL" />
      <updated>1602120477081</updated>
    </task>
    <option name="localTasksCounter" value="6" />
    <servers />
  </component>
  <component name="UnknownFeatures">
    <option featureType="com.intellij.fileTypeFactory" implementationName="*.env" />
  </component>
  <component name="Vcs.Log.Tabs.Properties">
    <option name="TAB_STATES">
      <map>
        <entry key="MAIN">
          <value>
            <State />
          </value>
        </entry>
      </map>
    </option>
    <option name="oldMeFiltersMigrated" value="true" />
  </component>
  <component name="VcsManagerConfiguration">
    <MESSAGE value="Fix bug in resume-at&#10;&#10;Also remove debug printing" />
    <MESSAGE value="Improve start-run! signature &#10;&#10;* fix bug in resume-at&#10;* remove debug printing" />
    <MESSAGE value="Get conditional flow tests working" />
    <MESSAGE value="Get conditional flow tests working&#10;&#10;Also convert all cljs files to clj to get rid of spurious symbol not found issues in IDE. We can add cljs support later if we need it." />
    <MESSAGE value="Get conditional flow tests working&#10;&#10;* convert all cljs files to clj to get rid of spurious symbol not found issues in IDE. We can add cljs support later if we need it.&#10;* fix warnings due to difficulty of importing InMemoryRunstore from a file with mismatched name" />
    <MESSAGE value="Fix test cases" />
    <MESSAGE value="Get if suspending-test case working&#10;&#10;* fix a small bug in the resume-at macro&#10;* rename runner to runloop.clj&#10;* convert remaining cljc =&gt; clj" />
    <option name="LAST_COMMIT_MESSAGE" value="Get if suspending-test case working&#10;&#10;* fix a small bug in the resume-at macro&#10;* rename runner to runloop.clj&#10;* convert remaining cljc =&gt; clj" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <breakpoints>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/longterm/operators.clj</url>
          <line>18</line>
          <option name="timeStamp" value="38" />
        </line-breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/longterm/flow.clj</url>
          <line>35</line>
          <option name="timeStamp" value="40" />
        </line-breakpoint>
      </breakpoints>
    </breakpoint-manager>
    <pin-to-top-manager>
      <pinned-members>
        <PinnedItemInfo parentTag="longterm.run.Run" memberName="id" />
      </pinned-members>
    </pin-to-top-manager>
  </component>
</project>